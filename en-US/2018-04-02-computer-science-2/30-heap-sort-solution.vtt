WEBVTT

1
00:00:00.370 --> 00:00:00.983
&gt;&gt; Brian Holt: Okay, so

2
00:00:00.983 --> 00:00:05.947
let's go ahead and,
&gt;&gt; Brian Holt: Take a look at how to

3
00:00:05.947 --> 00:00:06.504
do this.

4
00:00:17.294 --> 00:00:19.583
&gt;&gt; Brian Holt: This requires
about 50 lines of code.

5
00:00:25.435 --> 00:00:30.529
&gt;&gt; Brian Holt: So you're gonna
create a function here called, so

6
00:00:30.529 --> 00:00:37.400
the snapshot thing is how I'm able
to show the visualization there,

7
00:00:37.400 --> 00:00:41.901
so you can just basically ignore it.

8
00:00:41.901 --> 00:00:46.314
&gt;&gt; Brian Holt: And I gave you here,
basically, the guts.

9
00:00:46.314 --> 00:00:50.994
So you're gonna have a createMaxHeap
function, a heapify function,

10
00:00:50.994 --> 00:00:52.554
and then the heapSort,

11
00:00:52.554 --> 00:00:57.861
which is intern going to call both of
those functions internally from heapSort.

12
00:00:57.861 --> 00:01:03.105
So let's start with the create max-heap,
it's a pretty simple one.

13
00:01:03.105 --> 00:01:08.864
All you're gonna do is you're gonna

14
00:01:08.864 --> 00:01:15.697
start with a for loop and say let i is 0.

15
00:01:15.697 --> 00:01:22.847
&gt;&gt; Brian Holt: Sorry, i = Math.floor,
&gt;&gt; Brian Holt: Of

16
00:01:22.847 --> 00:01:28.347
array.length divided by 2,
and i is greater than or

17
00:01:28.347 --> 00:01:33.004
equal to 0, and then i minus minus, right?

18
00:01:33.004 --> 00:01:36.024
So you're gonna start from the middle
of the array and go backwards.

19
00:01:38.881 --> 00:01:44.791
&gt;&gt; Brian Holt: Then you're just gonna call
heapify on array, i, and array length.

20
00:01:50.821 --> 00:01:53.644
&gt;&gt; Brian Holt: And
you're gonna return to the array.

21
00:01:55.981 --> 00:01:59.171
&gt;&gt; Brian Holt: So the array,
right, that makes sense.

22
00:01:59.171 --> 00:02:01.838
The index of where we currently are,
that probably makes sense as well,

23
00:02:01.838 --> 00:02:03.440
cuz we're gonna be heapifying.

24
00:02:03.440 --> 00:02:08.885
And then we have to give it the heap size,
because remember when we're doing the heap

25
00:02:08.885 --> 00:02:13.961
sort part of it, the heap size makes a
difference of where and how far it can go.

26
00:02:13.961 --> 00:02:17.529
And you don't want it to go to the end of
the array when we're doing heap sort cuz

27
00:02:17.529 --> 00:02:20.032
otherwise it would mess up
the sorted part of the list.

28
00:02:20.032 --> 00:02:23.032
We wanna progressively make
our heap smaller and smaller,

29
00:02:23.032 --> 00:02:25.134
which is why we're passing in heap size.

30
00:02:27.053 --> 00:02:29.678
&gt;&gt; Brian Holt: So let's take
a look at what heapify looks like.

31
00:02:32.412 --> 00:02:38.824
&gt;&gt; Brian Holt: So here you're going to do,
&gt;&gt; Brian Holt: We'll call it at the end,

32
00:02:41.682 --> 00:02:44.331
&gt;&gt; Brian Holt: Const left = 2.

33
00:02:44.331 --> 00:02:48.204
So this is gonna be the left
child times index +1.

34
00:02:48.204 --> 00:02:52.103
Const right = 2 times index + 2.

35
00:02:55.931 --> 00:03:00.305
&gt;&gt; Brian Holt: So you're gonna say let

36
00:03:00.305 --> 00:03:05.998
largest ValueIndex = index.

37
00:03:08.722 --> 00:03:10.970
&gt;&gt; Brian Holt: Then here I'm just
gonna ask, if the left child bigger?

38
00:03:10.970 --> 00:03:12.441
Is the right child bigger?

39
00:03:12.441 --> 00:03:17.641
And if one of them was bigger,
then I'll swap them.

40
00:03:17.641 --> 00:03:20.289
If one of them's not bigger,
then I'll leave it, right?

41
00:03:20.289 --> 00:03:25.339
So I'm going to ask if

42
00:03:25.339 --> 00:03:30.389
heapSize, that is,

43
00:03:30.389 --> 00:03:35.448
yeah, yeah, yeah.

44
00:03:35.448 --> 00:03:41.564
So if heapSize is like out of
bounds that I'm not gonna check it,

45
00:03:41.564 --> 00:03:48.152
which is what you're doing here,
then you're gonna say end array.

46
00:03:50.100 --> 00:03:55.462
&gt;&gt; Brian Holt: Array
largest value index is

47
00:03:55.462 --> 00:04:01.725
less than array of left, right?

48
00:04:01.725 --> 00:04:02.677
So,

49
00:04:13.240 --> 00:04:13.915
&gt;&gt; Brian Holt: So the first time

50
00:04:13.915 --> 00:04:16.673
the largest value, you could just
as easily put index here as well.

51
00:04:16.673 --> 00:04:20.382
I just think it's a little
bit easier to read this way.

52
00:04:20.382 --> 00:04:25.852
So if left is greater than the parent,
right?

53
00:04:25.852 --> 00:04:29.888
The index,
then we're gonna swap the left child in.

54
00:04:29.888 --> 00:04:36.169
So largestValueIndex = left,

55
00:04:36.169 --> 00:04:41.254
if(heapSize
&gt;&gt; Brian Holt: If

56
00:04:41.254 --> 00:04:47.796
right is in bounds,
then you're gonna say and

57
00:04:47.796 --> 00:04:51.832
array largestValueIndex.

58
00:04:51.832 --> 00:04:53.219
Array right.

59
00:04:56.539 --> 00:05:02.124
&gt;&gt; Brian Holt: Then you're gonna
say largestValueIndex = right.

60
00:05:02.124 --> 00:05:03.020
Okay?

61
00:05:03.020 --> 00:05:03.956
So now I know for

62
00:05:03.956 --> 00:05:08.351
a fact that the largest value index
is definitely contained in this one.

63
00:05:08.351 --> 00:05:11.607
It's either the parent,
the left child, or the right child,

64
00:05:11.607 --> 00:05:13.523
after doing these two comparisons.

65
00:05:13.523 --> 00:05:19.252
Then I'm gonna say if
the largestValueIndex

66
00:05:19.252 --> 00:05:23.480
is not equal to, index, right?

67
00:05:23.480 --> 00:05:27.184
So If either the left child or the right
child is bigger then we have to do a swap.

68
00:05:27.184 --> 00:05:30.890
If it is the parent,
then you just leave it.

69
00:05:30.890 --> 00:05:31.944
Cool, do you follow?

70
00:05:33.570 --> 00:05:37.475
&gt;&gt; Brian Holt: Okay, then what we're
gonna do is just do a swap, right?

71
00:05:37.475 --> 00:05:43.768
const temp = array[index];

72
00:05:43.768 --> 00:05:47.498
array[index] =

73
00:05:47.498 --> 00:05:54.030
array[largestValueIndex].

74
00:05:55.916 --> 00:06:00.178
&gt;&gt; Brian Holt: Then, you're just gonna
say array[largestValueIndex] is gonna be

75
00:06:00.178 --> 00:06:01.178
assigned temp.

76
00:06:04.146 --> 00:06:07.720
&gt;&gt; Brian Holt: And then at this point, if
you remember, if we do heapify something,

77
00:06:07.720 --> 00:06:10.092
we have to heapify
the child that's swapped.

78
00:06:10.092 --> 00:06:13.332
Because we have to guarantee that
order still maintains further

79
00:06:13.332 --> 00:06:14.860
down the tree as well.

80
00:06:14.860 --> 00:06:17.579
So only if one of the swaps happens,

81
00:06:17.579 --> 00:06:22.848
we're gonna call it heapify on
the array at the largestValueIndex.

82
00:06:22.848 --> 00:06:30.154
And heapSize,
&gt;&gt; Brian Holt: Does that make sense?

83
00:06:30.154 --> 00:06:32.192
&gt;&gt; Student1: Are you keeping
track of the heapSize,

84
00:06:32.192 --> 00:06:36.100
because you're slowly making it smaller
until the whole thing is sorted?

85
00:06:36.100 --> 00:06:36.974
&gt;&gt; Brian Holt: Exactly.

86
00:06:36.974 --> 00:06:38.236
&gt;&gt; Student1: Okay.
&gt;&gt; Brian Holt: So the heap continues to

87
00:06:38.236 --> 00:06:39.982
get smaller and smaller and smaller.

88
00:06:39.982 --> 00:06:42.769
If I included the entire array every
single time, I would swap something to

89
00:06:42.769 --> 00:06:45.085
the end, and then it would just
get moved back up to the front.

90
00:06:45.085 --> 00:06:46.773
&gt;&gt; Student1: Okay,
you would never sort it.

91
00:06:46.773 --> 00:06:49.240
&gt;&gt; Brian Holt: Yeah.
&gt;&gt; Student1: Okay.

92
00:06:49.240 --> 00:06:51.183
&gt;&gt; Brian Holt: But that's astute.

93
00:06:51.183 --> 00:06:55.307
&gt;&gt; Student2: I think you have the wrong
greater and less-than on the right check.

94
00:07:02.643 --> 00:07:04.945
&gt;&gt; Brian Holt: I don't think so.

95
00:07:04.945 --> 00:07:08.275
&gt;&gt; Student2: Cuz you're saying the current
one is greater than the right one, but

96
00:07:08.275 --> 00:07:11.395
you're assigning right to the current or
to the largest.

97
00:07:11.395 --> 00:07:11.910
&gt;&gt; Brian Holt: Right.

98
00:07:11.910 --> 00:07:13.199
No, you're right, here.

99
00:07:13.199 --> 00:07:15.119
I was looking at this one.

100
00:07:15.119 --> 00:07:16.158
&gt;&gt; Student2: Yeah.

101
00:07:16.158 --> 00:07:17.335
&gt;&gt; Brian Holt: You were correct,
thank you.

102
00:07:21.582 --> 00:07:23.630
&gt;&gt; Brian Holt: Okay,
so now I have heapify.

103
00:07:23.630 --> 00:07:25.031
I have createMaxHeap.

104
00:07:25.031 --> 00:07:29.426
So definitely when I call createMaxHeap,

105
00:07:29.426 --> 00:07:36.270
at the end of that whole process I
will have a valid MaxHeap, okay?

106
00:07:36.270 --> 00:07:41.729
So what I'm gonna do here in
heapSort the first thing I'm going

107
00:07:41.729 --> 00:07:47.192
to do is say that array is assigned
createMaxHeap of the array.

108
00:07:47.192 --> 00:07:53.459
So now array is an assorted max heap.

109
00:07:53.459 --> 00:07:58.793
Then I'm gonna have this temp variable and
I'm gonna say for(let i = 0,

110
00:08:01.130 --> 00:08:03.804
&gt;&gt; Brian Holt: Sorry let i = array.length

111
00:08:03.804 --> 00:08:07.927
-1, cuz you can you don't have to start,

112
00:08:07.927 --> 00:08:14.734
yeah you don't have to do the last one
cuz by that point it will be sorted.

113
00:08:14.734 --> 00:08:16.192
i &gt; 0 and i --.

114
00:08:21.550 --> 00:08:23.622
&gt;&gt; Brian Holt: Okay?

115
00:08:23.622 --> 00:08:26.288
So what you're gonna do is you're
gonna say temp go to the end.

116
00:08:30.493 --> 00:08:33.377
&gt;&gt; Brian Holt: Or
rather temp is going to be the first item.

117
00:08:33.377 --> 00:08:37.531
array[0] is going to become array at i,
right?

118
00:08:37.531 --> 00:08:40.253
Because we're going to be swapping these.

119
00:08:44.932 --> 00:08:49.365
&gt;&gt; Brian Holt: array i is
going to be assigned temp,

120
00:08:49.365 --> 00:08:54.084
heapSize--, and then you're gonna

121
00:08:54.084 --> 00:08:59.243
call heapify with the array, 0, right?

122
00:08:59.243 --> 00:09:02.381
Cuz heapify, you're always starting
from the beginning, right,

123
00:09:02.381 --> 00:09:04.230
because that's the one you swapped in.

124
00:09:04.230 --> 00:09:10.649
And heapSize which is progressively
getting smaller each time that you do it.

125
00:09:10.649 --> 00:09:12.471
&gt;&gt; Student2: Where
are you setting heapSize?

126
00:09:12.471 --> 00:09:14.641
&gt;&gt; Brian Holt: Right here,
the -- previous to it.

127
00:09:21.012 --> 00:09:25.914
&gt;&gt; Brian Holt: And
I didn't do it up here, no you're right,

128
00:09:25.914 --> 00:09:31.464
up here,
let heapSize start as the array.length.

129
00:09:36.200 --> 00:09:39.860
&gt;&gt; Brian Holt: So again,
just to walk you through it.

130
00:09:39.860 --> 00:09:42.383
Treat your variables up here,

131
00:09:42.383 --> 00:09:46.953
heapSize is going to be
the entire array the first time.

132
00:09:46.953 --> 00:09:49.613
We're going to make the array a max heap,

133
00:09:49.613 --> 00:09:54.864
which we do here by calling heapify on
every individual item in the array, right?

134
00:09:54.864 --> 00:09:58.205
Or rather, make sure that every
item gets affected by a heapify,

135
00:09:58.205 --> 00:10:00.100
which is why you start in the middle.

136
00:10:00.100 --> 00:10:04.544
Because remember, it's 2n plus 1, which
means if I'm heapifying from the middle,

137
00:10:04.544 --> 00:10:07.021
it's going to be looking
at the end of the array.

138
00:10:07.021 --> 00:10:09.940
Which is why that works.

139
00:10:09.940 --> 00:10:13.403
Heapify just goes through, and just makes
sure that the parent is always larger than

140
00:10:13.403 --> 00:10:15.412
the children,
that's the entire gist of that.

141
00:10:15.412 --> 00:10:17.366
If not, it sweeps, it swaps them and

142
00:10:17.366 --> 00:10:20.910
then it makes sure to call heapify
on the children that it swapped.

143
00:10:20.910 --> 00:10:23.346
Only the children that it swapped.

144
00:10:23.346 --> 00:10:26.871
Once we've done that we have a max
heap and we can go from there.

145
00:10:26.871 --> 00:10:34.120
And just be swapping out items and
calling heapify on the zero element.

146
00:10:34.120 --> 00:10:38.879
So, hopefully,
that gives us a sorted array.

147
00:10:38.879 --> 00:10:39.816
It does.

148
00:10:41.941 --> 00:10:42.831
&gt;&gt; Brian Holt: How do
you feel about heaps?

149
00:10:42.831 --> 00:10:44.789
Does that make some sense?

150
00:10:44.789 --> 00:10:45.391
Cool.

151
00:10:45.391 --> 00:10:48.942
It's a little difficult
to explain this a little,

152
00:10:48.942 --> 00:10:52.831
It's not terribly concrete
until you actually see it.

153
00:10:52.831 --> 00:10:55.640
But yeah, hopefully that explains it.

154
00:10:55.640 --> 00:10:59.315
If you wanna see what it looks like
when you do a lot more numbers,

155
00:10:59.315 --> 00:11:01.779
you can just swap these tests out, run it.

156
00:11:04.680 --> 00:11:08.675
&gt;&gt; Brian Holt: And you can see that
the nice pretty colored gradients.

