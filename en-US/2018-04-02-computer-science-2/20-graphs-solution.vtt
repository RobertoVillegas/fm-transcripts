WEBVTT

1
00:00:00.360 --> 00:00:02.650
&gt;&gt; Brian Holt: Hopefully,
you had some time traversing some graphs.

2
00:00:02.650 --> 00:00:07.270
We're gonna talk about now how to do it.

3
00:00:11.136 --> 00:00:13.734
&gt;&gt; Brian Holt: We wanna
go to the exercise.

4
00:00:18.600 --> 00:00:23.590
&gt;&gt; Brian Holt: Okay, so,
&gt;&gt; Brian Holt: Looking at this.

5
00:00:25.698 --> 00:00:29.832
&gt;&gt; Brian Holt: Yeah, I will implement
this very functionally in nature,

6
00:00:29.832 --> 00:00:34.140
just again, that's how my brain
tends to break down things.

7
00:00:34.140 --> 00:00:38.830
I don't know if it's Stockholm syndrome or
what, but after you're doing things and so

8
00:00:38.830 --> 00:00:41.470
many times in a certain way,
it's just kind of keep doing it that way.

9
00:00:41.470 --> 00:00:43.970
But you could definitely solve
this in a less functional style.

10
00:00:45.696 --> 00:00:48.280
I was struggling with how to show
people how to do these sorts of things,

11
00:00:48.280 --> 00:00:50.580
like should I break it down
to a more ideative approach.

12
00:00:50.580 --> 00:00:55.160
And I always land back on is like, I think
this is a useful way to show people how to

13
00:00:55.160 --> 00:00:58.480
write code, even if it's not
necessarily the central focus.

14
00:00:58.480 --> 00:01:01.650
You'll kind of begin to be more
exposed to these sorts of things,

15
00:01:01.650 --> 00:01:05.170
so good and bad, I am sure.

16
00:01:05.170 --> 00:01:07.850
It makes it a little bit more
cognitive load to understand it.

17
00:01:10.847 --> 00:01:17.171
&gt;&gt; Brian Holt: So first thing I'm gonna
do is I'm going to construct my queue.

18
00:01:17.171 --> 00:01:20.817
So let queue equal, and

19
00:01:20.817 --> 00:01:26.285
I'm gonna just put my ID as the first

20
00:01:26.285 --> 00:01:30.490
thing in the queue, okay?

21
00:01:30.490 --> 00:01:35.020
And then I'm gonna create a new set.

22
00:01:37.690 --> 00:01:42.700
So you could just do this totally with
just a plain old JavaScript object,

23
00:01:42.700 --> 00:01:44.200
that's totally fine.

24
00:01:44.200 --> 00:01:46.860
I'm gonna do with a set, because
this is what sets were created for,

25
00:01:46.860 --> 00:01:48.910
so might as well use it.

26
00:01:48.910 --> 00:01:52.530
A set, one you should go check
out version one of this course.

27
00:01:52.530 --> 00:01:55.010
I feel like I haven't said that enough,
so I'm gonna say it again.

28
00:01:55.010 --> 00:01:59.329
I talk all about what sets are,
but the short version is that they

29
00:01:59.329 --> 00:02:04.100
are business like this amorphous cloud
of data that you throw things into and

30
00:02:04.100 --> 00:02:06.840
you ask later, does this contain this?

31
00:02:06.840 --> 00:02:07.670
Like a Bloom filter but

32
00:02:07.670 --> 00:02:11.920
this will definitely give you a yes or
no answer, definitively yes or no.

33
00:02:11.920 --> 00:02:14.610
So what I'm gonna do is I'm gonna throw
IDs in here that I've seen before, so

34
00:02:14.610 --> 00:02:16.420
I do not process them again, right?

35
00:02:19.260 --> 00:02:23.420
And then I'm going to keep
an object called jobs, and

36
00:02:23.420 --> 00:02:25.610
I'm just gonna make that
a plain old JavaScript object.

37
00:02:25.610 --> 00:02:28.941
You could do this with a map,
but I'm not going to.

38
00:02:28.941 --> 00:02:30.650
I'll put it that way, you could.

39
00:02:33.710 --> 00:02:38.040
So what I'm gonna do here
is I'm gonna do a for loop.

40
00:02:38.040 --> 00:02:42.325
So let i equal 0, and

41
00:02:42.325 --> 00:02:48.514
then i is going to be less than or

42
00:02:48.514 --> 00:02:56.383
equal to degrees of separation I++.

43
00:02:56.383 --> 00:02:59.140
I think I set up here to count yourself.

44
00:03:02.590 --> 00:03:05.570
Yes, count initial IDs own
job in the title as well.

45
00:03:05.570 --> 00:03:08.960
So probably should have
said that out loud.

46
00:03:08.960 --> 00:03:13.910
Now I am saying it out loud, but
hopefully you get it up there.

47
00:03:13.910 --> 00:03:15.440
So that's why I'm able to go up.

48
00:03:15.440 --> 00:03:17.470
So I'm gonna start at 0 and then go 2, 4.

49
00:03:17.470 --> 00:03:18.740
It's cuz I'm gonna count myself.

50
00:03:18.740 --> 00:03:23.220
I am not separated from myself,
as far as I know, that's impossible.

51
00:03:25.810 --> 00:03:27.060
So we're gonna start with that.

52
00:03:27.060 --> 00:03:30.442
And we're gonna up to that
degree of separation, okay?

53
00:03:30.442 --> 00:03:35.900
And we're gonna do some functional foo
on this and see what that looks like.

54
00:03:35.900 --> 00:03:42.530
So q is going to equal to q, the first
thing we're gonna do is adopt filter.

55
00:03:43.760 --> 00:03:46.963
So this is like the last one
that I haven't talked about,

56
00:03:46.963 --> 00:03:50.770
filter is I'm gonna apply a function
to everything in a array.

57
00:03:50.770 --> 00:03:52.670
Things that are true stay in the array and

58
00:03:52.670 --> 00:03:56.550
things that are returned false
are removed from the array, right?

59
00:03:56.550 --> 00:03:57.060
Make sense?

60
00:03:58.070 --> 00:04:00.850
So the first thing I'm gonna do is
I'm gonna remove everything that I've

61
00:04:00.850 --> 00:04:01.548
seen before.

62
00:04:01.548 --> 00:04:09.520
So filter ID and return things
that have not been seen before.

63
00:04:12.593 --> 00:04:13.672
&gt;&gt; Brian Holt: Right?

64
00:04:15.960 --> 00:04:20.860
&gt;&gt; Brian Holt: And
this is an implicit return in JavaScript.

65
00:04:20.860 --> 00:04:25.357
So this is the same as saying,
&gt;&gt; Brian Holt: Right?

66
00:04:27.040 --> 00:04:29.520
&gt;&gt; Brian Holt: So
this is just the shorthand for that.

67
00:04:32.262 --> 00:04:37.998
&gt;&gt; Brian Holt: It's a little less dense,
that's why I like that.

68
00:04:37.998 --> 00:04:42.915
Okay, then I wanna transform
every item in this list

69
00:04:42.915 --> 00:04:47.290
from the ID to the actual user object,
right?

70
00:04:48.300 --> 00:04:51.260
So I'm gonna do a .map and do getUser.

71
00:04:53.860 --> 00:04:58.091
Some people have a hard time kind of
parsing that, so just to show you

72
00:04:58.091 --> 00:05:02.790
what that looks like, it would be
the same as doing ID, return ID, right?

73
00:05:02.790 --> 00:05:07.409
So it would be taking that parameter and
feeding it into getUser, right,

74
00:05:07.409 --> 00:05:09.950
which is the same as doing that, right?

75
00:05:09.950 --> 00:05:13.220
Because you are just taking
a parameter and passing it in, so

76
00:05:13.220 --> 00:05:17.020
you don't have to create
this extraneous function.

77
00:05:17.020 --> 00:05:19.080
How do we feel about that, is that okay?

78
00:05:19.080 --> 00:05:22.650
So it's gonna take a list of IDs, like
one, two, three, four, and then it's gonna

79
00:05:22.650 --> 00:05:28.570
be afterwards an array of user object one,
user object two, user object three.

80
00:05:28.570 --> 00:05:30.540
So that's what's happening here.

81
00:05:30.540 --> 00:05:31.089
We okay with that?

82
00:05:33.720 --> 00:05:34.220
&gt;&gt; Brian Holt: Okay.

83
00:05:36.743 --> 00:05:39.070
&gt;&gt; Brian Holt: Then we'll
gonna do here another map.

84
00:05:40.490 --> 00:05:42.590
&gt;&gt; Brian Holt: So
I'm gonna have user objects here now.

85
00:05:49.775 --> 00:05:54.801
&gt;&gt; Brian Holt: So
what I'm gonna do here, I'm think

86
00:05:54.801 --> 00:06:02.667
I'm gonna say jobs user.title
equals jobs user.title.

87
00:06:02.667 --> 00:06:08.210
So, [COUGH] jobs, this is everything
that I've seen before, right?

88
00:06:08.210 --> 00:06:10.290
If I've never seen this
user's title before,

89
00:06:10.290 --> 00:06:13.420
I'm gonna need to add it to my object,
right?

90
00:06:13.420 --> 00:06:17.630
And if I have seen it before,
then I need to increase it by one, right?

91
00:06:17.630 --> 00:06:21.301
So if I've seen that before,
then I just want to add one,

92
00:06:21.301 --> 00:06:24.144
and if not then I want to make it one,
right?

93
00:06:24.144 --> 00:06:26.430
You could do this with an if statement.

94
00:06:26.430 --> 00:06:28.940
I'm gonna do it with what's
called a turn array.

95
00:06:28.940 --> 00:06:31.880
Hopefully, you've seen these before, but

96
00:06:31.880 --> 00:06:35.370
if not,
it's basically a compressed if statement.

97
00:06:35.370 --> 00:06:42.780
So if I've seen it before, then add one,
let's just make this a little bit smaller.

98
00:06:42.780 --> 00:06:44.795
And if I haven't seen it before,
then do just one.

99
00:06:44.795 --> 00:06:51.240
So again,
turn your smushed together if statements.

100
00:06:51.240 --> 00:06:54.700
This asks a question, does this exist?

101
00:06:54.700 --> 00:06:58.480
If true, then it's the first thing,
if it's false it's the second thing.

102
00:06:58.480 --> 00:07:04.307
So the first thing here, if it's true,
if it does exist, then add one.

103
00:07:04.307 --> 00:07:06.120
And if it doesn't exist, then it is one.

104
00:07:07.730 --> 00:07:10.077
&gt;&gt; Brian Holt: It's all dense, but cool.

105
00:07:13.796 --> 00:07:20.880
&gt;&gt; Brian Holt: Next we're going
to say seen.add, user.id, right?

106
00:07:20.880 --> 00:07:23.120
Because we don't want to process
this user.id ever again.

107
00:07:23.120 --> 00:07:23.940
We processed it once and now it's done.

108
00:07:23.940 --> 00:07:29.339
And then we're going to return user.

109
00:07:31.280 --> 00:07:35.398
&gt;&gt; Brian Holt: I know someone is out there
who's very functionally inclined saying

110
00:07:35.398 --> 00:07:39.374
you're doing side effects on a map,
and you should be doing that,

111
00:07:39.374 --> 00:07:40.870
in that voice actually.

112
00:07:42.830 --> 00:07:48.290
Which is true, typically inside of
maps you don't wanna do side effects

113
00:07:48.290 --> 00:07:52.730
which is basically modifying state of the
outside world, right, I'm modifying jobs.

114
00:07:52.730 --> 00:07:55.690
I'm doing all that, and
then I'm just returning user at the end.

115
00:07:55.690 --> 00:07:59.196
The reason why I'm doing this
versus doing it for each,

116
00:07:59.196 --> 00:08:02.710
is four h does not return
an array at the end and map does.

117
00:08:02.710 --> 00:08:06.758
So I can keep doing my functional stuff
below here, whereas if I did four h I

118
00:08:06.758 --> 00:08:10.440
would have to stop and restart again,
and I didn't wanna do that.

119
00:08:10.440 --> 00:08:14.950
So that's why for whatever functional
person out there is scoffing at me,

120
00:08:14.950 --> 00:08:18.530
you can keep scoffing but
I don't care doesn't hurt.

121
00:08:20.980 --> 00:08:22.450
So now I've done that.

122
00:08:22.450 --> 00:08:26.250
Now I've added it to my jobs object.

123
00:08:27.360 --> 00:08:31.570
And now what I wanna do is

124
00:08:35.040 --> 00:08:38.490
I wanna transform this

125
00:08:38.490 --> 00:08:43.150
from this map of numbers to the map
of their connections, right?

126
00:08:44.270 --> 00:08:47.130
So I have a bunch of user objects
that have a bunch of connections.

127
00:08:47.130 --> 00:08:52.940
I've already processed all
the users in that particular queue,

128
00:08:52.940 --> 00:08:55.770
and I want to go and
do the next level down, right?

129
00:08:55.770 --> 00:08:58.920
So what I'm gonna do is I'm
going to get the users.

130
00:09:01.340 --> 00:09:08.400
&gt;&gt; Brian Holt: And then I'm going to
transform that into the user.connections.

131
00:09:11.910 --> 00:09:13.660
&gt;&gt; Brian Holt: Right?

132
00:09:13.660 --> 00:09:16.240
But now I have an array of arrays,
which I don't really want.

133
00:09:17.660 --> 00:09:19.990
I just want a flat array,
does that make sense?

134
00:09:21.120 --> 00:09:23.640
Cuz whatever you return here is
what gets put in the array, and

135
00:09:23.640 --> 00:09:26.252
right now it's just an array of arrays and
that's not what I want.

136
00:09:26.252 --> 00:09:30.370
So ideally, we'd wanna be able to call
flatten here which doesn't exist yet,

137
00:09:30.370 --> 00:09:33.100
cuz it's gonna call smush and
I'm not bitter.

138
00:09:33.100 --> 00:09:35.426
It's not like I've already
talked about this today.

139
00:09:35.426 --> 00:09:40.300
I'm gonna imprint, flat would be perfect
cuz that would work exactly like I

140
00:09:40.300 --> 00:09:44.270
would want it to, but we're just gonna do
it in terms of reduce because that works.

141
00:09:44.270 --> 00:09:46.710
So you're gonna have acc and users.

142
00:09:47.870 --> 00:09:54.784
And I'm going to return acc.concat users.

143
00:09:57.240 --> 00:09:58.610
&gt;&gt; Brian Holt: And that should work.

144
00:09:58.610 --> 00:10:01.510
I don't think you even need the seed,
nope, you shouldn't.

145
00:10:01.510 --> 00:10:07.550
So,
&gt;&gt; Brian Holt: Cool.

146
00:10:07.550 --> 00:10:08.270
Questions about that?

147
00:10:11.140 --> 00:10:16.000
&gt;&gt; Brian Holt: So now after we've
done all of that, queue will now be

148
00:10:16.000 --> 00:10:21.920
the next iterations amount
of user connections, right?

149
00:10:21.920 --> 00:10:27.350
So thinking about that, we're gonna
start off with just my ID, right?

150
00:10:27.350 --> 00:10:30.620
So it's gonna filter anything out
it's seen before, which is nothing.

151
00:10:30.620 --> 00:10:31.814
It's never seen anything before.

152
00:10:31.814 --> 00:10:36.465
It's gonna turn my connection, so
let's just pretend it's 30 I think

153
00:10:36.465 --> 00:10:39.130
is the first one down here,
right, so it's user 30.

154
00:10:39.130 --> 00:10:41.610
So this is just going
to be an array of 30.

155
00:10:41.610 --> 00:10:45.710
Let's just put a comment there,
so you can see it, right?

156
00:10:45.710 --> 00:10:49.610
Here, it will do nothing because it's
never seen anything, so do nothing.

157
00:10:51.010 --> 00:10:57.270
Now it's going to be ID 30,
title blah, right?

158
00:10:57.270 --> 00:10:58.764
So it's gonna be that object.

159
00:11:02.015 --> 00:11:06.500
&gt;&gt; Brian Holt: Here, it's still gonna
be the same array as before, but

160
00:11:06.500 --> 00:11:09.220
there were side effects, right?

161
00:11:09.220 --> 00:11:14.104
So we did a bunch of stuff off on the side
&gt;&gt; Brian Holt: Okay,

162
00:11:14.104 --> 00:11:19.067
now this is going to be
an array of arrays of all

163
00:11:19.067 --> 00:11:23.720
of it's various connections, right?

164
00:11:23.720 --> 00:11:28.610
And then what we're going to get
back here is just 1, 2, 3, 4, right?

165
00:11:28.610 --> 00:11:33.426
So it's going to flatten
that array down to one flat

166
00:11:33.426 --> 00:11:37.460
array of all of user 30's connections.

167
00:11:38.750 --> 00:11:40.012
We follow kind of the progression there?

168
00:11:40.012 --> 00:11:41.630
Does that make sense?

169
00:11:43.210 --> 00:11:47.200
So again, you could totally implement
this without using mat filter and reduce.

170
00:11:47.200 --> 00:11:50.120
But to me, I find this preferable code.

171
00:11:52.050 --> 00:11:56.099
But you can disagree with me and
we'll just fight about it, and

172
00:11:56.099 --> 00:12:00.200
that's okay.

173
00:12:00.200 --> 00:12:02.740
So now it's going to go do this for
all the degrees of separation.

174
00:12:02.740 --> 00:12:08.280
After this four loop completes,
I will have this jobs object

175
00:12:08.280 --> 00:12:13.280
that's just going to be, the key will
be in various amounts of jobs and

176
00:12:13.280 --> 00:12:15.120
the numbers will be how
many times I saw the jobs.

177
00:12:15.120 --> 00:12:18.280
So now I just need to get the one
that was seen the most, right?

178
00:12:20.400 --> 00:12:21.740
Good?
Good so far?

179
00:12:21.740 --> 00:12:26.620
Okay, so
what I'm gonna do down here is more

180
00:12:27.880 --> 00:12:30.435
functional bullshit, I'm just kidding,
functional programming

181
00:12:41.020 --> 00:12:45.547
&gt;&gt; Brian Holt: So object.keys, all right,

182
00:12:45.547 --> 00:12:48.860
so let's start here.

183
00:12:48.860 --> 00:12:49.922
Jobs is going to be,

184
00:12:49.922 --> 00:12:54.110
the thing that we're gonna get out of
this is jobs that's the important thing.

185
00:12:54.110 --> 00:12:59.160
Jobs is going to be this object,

186
00:12:59.160 --> 00:13:03.580
where it's gonna have like
dev is gonna be like 50 and

187
00:13:03.580 --> 00:13:08.510
designer, it's going to be like 30, right?

188
00:13:10.070 --> 00:13:11.170
Etcetera, etcetera, etcetera.

189
00:13:12.350 --> 00:13:14.340
Now we need to pull out of this,

190
00:13:14.340 --> 00:13:16.290
the one that was seeing the most
amounts of times, right?

191
00:13:16.290 --> 00:13:18.650
The job title,
that was seeing the most amount of times.

192
00:13:20.040 --> 00:13:23.520
So object key is going to give me back
all of these, right, as an array.

193
00:13:25.300 --> 00:13:29.320
So now I have this array of job titles.

194
00:13:29.320 --> 00:13:34.300
And what I want to do is I want to return,
&gt;&gt; Brian Holt: First,

195
00:13:34.300 --> 00:13:39.872
what I'm gonna do here is job and
I'm going to return tupple,

196
00:13:39.872 --> 00:13:44.490
a tupple,
that's the name of the data structure.

197
00:13:44.490 --> 00:13:46.490
It's just like an array of two, right?

198
00:13:47.730 --> 00:13:51.230
Apparently, it's pronounce
tupple I was told, I don't care.

199
00:13:51.230 --> 00:13:57.809
I'm gonna hold on to tupple till I die,
and I will fight you about it.

200
00:13:57.809 --> 00:13:59.950
&gt;&gt; Brian Holt: So
what I want is I want an array of two.

201
00:13:59.950 --> 00:14:04.290
I wanna have both the job title and
how many times I saw it, right?

202
00:14:04.290 --> 00:14:10.980
So it's gonna be job and
then job's job, [LAUGH] right?

203
00:14:10.980 --> 00:14:18.130
So this is going to be, using our example
above, it's going to be dev50, right?

204
00:14:18.130 --> 00:14:21.640
So now I can sort these based on which one
I saw the most amount of times, right?

205
00:14:21.640 --> 00:14:25.632
So I'm kind of creating these
intermediary data structures.

206
00:14:27.466 --> 00:14:32.806
&gt;&gt; Brian Holt: Now I'm just gonna run a
really dumb sorting function, so a and b.

207
00:14:36.114 --> 00:14:38.915
&gt;&gt; Brian Holt: And
indent that a little bit.

208
00:14:38.915 --> 00:14:42.925
So I'm just gonna say, If a of one,
cuz one a of one, right,

209
00:14:42.925 --> 00:14:44.830
is going to be 50, right?

210
00:14:44.830 --> 00:14:49.830
So we're comparing the numbers versus
each other, that's what we care about.

211
00:14:49.830 --> 00:14:55.530
Is greater than b of one,
then return negative one.

212
00:14:58.240 --> 00:14:59.338
&gt;&gt; Speaker 2: So my question is,

213
00:14:59.338 --> 00:15:03.191
why were you doing the object.keys
instead of object.entries?

214
00:15:05.408 --> 00:15:11.835
&gt;&gt; Brian Holt: That's for-in loop,
the answer is it probably both works.

215
00:15:11.835 --> 00:15:17.072
I am just so used to using object.keys

216
00:15:17.072 --> 00:15:24.010
that,
&gt;&gt; Brian Holt: Yeah, today I learned.

217
00:15:24.010 --> 00:15:25.580
I think you could use either one of them.

218
00:15:25.580 --> 00:15:29.330
It looks like here,
I'm gonna guess that object.keys works.

219
00:15:29.330 --> 00:15:31.950
Yeah, this is ES 2017.

220
00:15:31.950 --> 00:15:36.990
So object keys works a little bit sooner,
but that's whatever, right?

221
00:15:36.990 --> 00:15:37.850
They both work.

222
00:15:37.850 --> 00:15:39.810
So thanks for teaching me something.

223
00:15:44.290 --> 00:15:48.790
&gt;&gt; Brian Holt: Cool, so sort.

224
00:15:48.790 --> 00:15:52.750
I think you've probably all
seen this .sort method before.

225
00:15:52.750 --> 00:15:55.340
It's been in JavaScript since forever.

226
00:15:55.340 --> 00:15:57.400
Sometimes, if you need to you
can tell it how to sort things.

227
00:15:57.400 --> 00:16:00.839
So I'm telling it to sort based on
the first item in these arrays,

228
00:16:00.839 --> 00:16:03.415
because it's going to be
a bunch of these pairs.

229
00:16:03.415 --> 00:16:10.110
This is gonna be 1, and
this is just how you write them.

230
00:16:10.110 --> 00:16:13.452
If a is greater than you
return negative one.

231
00:16:13.452 --> 00:16:18.390
If b is greater,
&gt;&gt; Brian Holt: Then

232
00:16:18.390 --> 00:16:20.670
you return a positive number.

233
00:16:20.670 --> 00:16:22.020
It actually doesn't matter.

234
00:16:22.020 --> 00:16:23.820
Negative number, a positive number, and

235
00:16:23.820 --> 00:16:26.680
then if they are equal
then you return zero.

236
00:16:31.890 --> 00:16:33.386
&gt;&gt; Brian Holt: It's important
that you do it this way,

237
00:16:33.386 --> 00:16:35.680
otherwise things are going
to get way out of order.

238
00:16:35.680 --> 00:16:37.440
And it's also important
that you return zero or

239
00:16:37.440 --> 00:16:43.450
it's gonna be less effective than it could
have been, less efficient rather, okay?

240
00:16:45.290 --> 00:16:51.040
So at the end of this, I'm gonna have a
list of these like pairs of items, right?

241
00:16:51.040 --> 00:16:54.720
And the top one is going to be
the one that was seen the most, right?

242
00:16:54.720 --> 00:16:59.048
So I wanna take the zero element,
which is going to be dev50, right?

243
00:16:59.048 --> 00:17:04.930
And I wanna take the zero element of that,
which is going to be 0, right?

244
00:17:05.990 --> 00:17:09.540
So if I return that,
it's going to give back dev,

245
00:17:09.540 --> 00:17:11.380
which is ultimately what we wanted.

246
00:17:13.030 --> 00:17:14.740
How do we feel about that?

247
00:17:14.740 --> 00:17:17.710
Did we follow kind of like the progression
of steps that we got there?

248
00:17:20.030 --> 00:17:23.890
So for some of you this might be
like an entirely new paradigm of

249
00:17:23.890 --> 00:17:25.240
programming this way.

250
00:17:25.240 --> 00:17:27.630
I'll tell you this is how I try and
write most of my code.

251
00:17:28.730 --> 00:17:31.280
But you could, go ahead.

252
00:17:31.280 --> 00:17:33.998
&gt;&gt; Speaker 3: Is there a reason you
didn't just do a reduce on that and

253
00:17:33.998 --> 00:17:35.900
grab whatever's the biggest value?

254
00:17:35.900 --> 00:17:39.460
&gt;&gt; Brian Holt: You could totally put
this in terms of reduce as well, yeah.

255
00:17:44.980 --> 00:17:47.200
They'd be roughly the same
efficiency as well.

256
00:17:47.200 --> 00:17:50.410
But I applaud that you're thinking
like that, I think that's great.

257
00:17:53.580 --> 00:17:59.360
&gt;&gt; Brian Holt: So I think this should
work as is, let's give it a shot.

258
00:18:04.700 --> 00:18:07.050
&gt;&gt; Brian Holt: And cool,
you should be seeing that.

259
00:18:07.050 --> 00:18:09.500
So let's go ahead and give it the extra
cut at once and see what happens.

260
00:18:15.140 --> 00:18:20.140
&gt;&gt; Brian Holt: And it gets every user
within a seven degrees separation.

261
00:18:23.140 --> 00:18:24.700
&gt;&gt; Brian Holt: Questions about this?

262
00:18:30.099 --> 00:18:33.130
&gt;&gt; Brian Holt: Or is your brain kind
of melting out one side of the ear?

263
00:18:33.130 --> 00:18:34.465
Okay, cool, me too.

264
00:18:34.465 --> 00:18:37.713
[LAUGH] Let's bond together and
get through this.

265
00:18:37.713 --> 00:18:41.329
[LAUGH] I thought it was funny
that the most common job title of

266
00:18:41.329 --> 00:18:43.510
the network Geological Engineer.

267
00:18:45.060 --> 00:18:46.449
That's very realistic.

268
00:18:46.449 --> 00:18:52.582
This is actually modeled after
real world things, just kidding.

269
00:18:52.582 --> 00:18:58.690
Okay, so
any questions about graphs in general?

270
00:18:58.690 --> 00:19:03.277
Conceptually, do we follow what's kind of
happening here that we're just kind of

271
00:19:03.277 --> 00:19:07.733
going down one layer each time until we
reach our desired degree of separation and

272
00:19:07.733 --> 00:19:10.550
then just kind of racking those up?

273
00:19:10.550 --> 00:19:13.080
That's the important thing that I
really want you to take away from this.

